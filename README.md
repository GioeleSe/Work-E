# Work-E
4 robots who will overtake the universe (and small paper blocks)\
\
This repository documents the architecture, communication flow, and API surface of a simple robotic control system composed of a web-based GUI, a Python backend, and multiple UDP-connected robot nodes (MCUs).\
\
There will be 6 branches, one for each robot, one for the server and the main one.

## Scripts Structure
### 1. Single Page Application (SPA)
A standalone frontend with no external web server dependency (single HTML + JavaScript bundle).
* **Manual Commands Page**
  * Direct, low-level control of board parameters
  * Debug-oriented interface
* **Automatic Commands Page**
  * Higher-level abstraction
  * Clean, task-oriented GUI
---


### 2. Python Server (HTTP + UDP)
* **HTTP Server**
  * Connects the SPA to the backend
  * Responsibilities:
    * Receive user input from the GUI
    * Return action results and responses

* **UDP Server**
  * Handles communication with MCUs
  * Responsibilities:
    * Periodic health checks of online nodes and their status (visible in the manual/debug GUI)
    * Transmission of properties and commands via UDP packets
    * MCUs tracking and task checking
  * Message structure and endpoints defined in MCU_API.md
---

### 3. UDP-Connected Nodes (Robot MCUs)
Initially Arduino-based (PlatformIO planned later)
* Each node runs:
  * A UDP server listening for incoming packets
  * A client function for sending on-demand packets (lighter than full-duplex session)

* Responsibilities:
  * Connect to a predefined network with a fixed server IP
  * Send UDP packets for significant and debug events
  * Activate robot-specific functionalities
    * e.g. max-size checker, obstacle remover
  * Generate routes to get to load position, base, and load destination
  * Track position while moving within the playground
  * Detect obstacles and generate alternative routes

## User-to-ESP32 General Flow

### GUI Command: `Set Property i Of Robot k`
* Query robot status (offline / busy / error)
* Apply property change
* Update the GUI accordingly

### GUI Command: `Collect Items At (X, Y)`
Translated by the backend into multiple coordinated actions:
* Retrieve status of all robots
  * Abort if any robot is busy -> Return a "wait for previous jobs" message
* Apply session-level settings:
  * Desired speed
  * Debug level
  * Feedback level
  * Active functionalities
  * Navigation type
  * Home position
* Set load position and its final destination
* Validate paths generated by each node
* Start navigation
* Handle runtime events:
  * Obstacles encountered
  * Points of Interest (POI) reached
* Update the GUI with the current state
